import { useState, useEffect, useCallback, useRef } from 'react';

export const useWebSocket = (url) => {
  const [isConnected, setIsConnected] = useState(false);
  const [messages, setMessages] = useState([]);
  const [error, setError] = useState(null);
  const socketRef = useRef(null);

  const connect = useCallback(() => {
    try {
      socketRef.current = new WebSocket(url);
      
      socketRef.current.onopen = () => {
        setIsConnected(true);
        setError(null);
        setMessages(prev => [...prev, {
          id: Date.now(),
          type: 'system',
          content: 'âœ… Ð—\'Ñ”Ð´Ð½Ð°Ð½Ð½Ñ Ð²ÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¾!',
          timestamp: new Date().toISOString()
        }]);
      };

      socketRef.current.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          setMessages(prev => [...prev, {
            id: Date.now(),
            ...data,
            timestamp: data.timestamp || new Date().toISOString()
          }]);
        } catch (e) {
          setMessages(prev => [...prev, {
            id: Date.now(),
            type: 'message',
            content: event.data,
            timestamp: new Date().toISOString()
          }]);
        }
      };

      socketRef.current.onclose = () => {
        setIsConnected(false);
        setMessages(prev => [...prev, {
          id: Date.now(),
          type: 'system',
          content: 'âŒ Ð—\'Ñ”Ð´Ð½Ð°Ð½Ð½Ñ Ð·Ð°ÐºÑ€Ð¸Ñ‚Ð¾',
          timestamp: new Date().toISOString()
        }]);
      };

      socketRef.current.onerror = (error) => {
        setIsConnected(false);
        setError('ÐŸÐ¾Ð¼Ð¸Ð»ÐºÐ° Ð·\'Ñ”Ð´Ð½Ð°Ð½Ð½Ñ');
        console.error('WebSocket Ð¿Ð¾Ð¼Ð¸Ð»ÐºÐ°:', error);
      };

    } catch (error) {
      setError('ÐÐµ Ð²Ð´Ð°Ð»Ð¾ÑÑ Ð¿Ñ–Ð´ÐºÐ»ÑŽÑ‡Ð¸Ñ‚Ð¸ÑÑ Ð´Ð¾ ÑÐµÑ€Ð²ÐµÑ€Ð°');
      console.error('ÐŸÐ¾Ð¼Ð¸Ð»ÐºÐ° Ð¿Ñ–Ð´ÐºÐ»ÑŽÑ‡ÐµÐ½Ð½Ñ:', error);
    }
  }, [url]);

  const disconnect = useCallback(() => {
    if (socketRef.current) {
      socketRef.current.close();
      socketRef.current = null;
    }
  }, []);

  const sendMessage = useCallback((message, type = 'message') => {
    if (socketRef.current && isConnected) {
      const data = {
        type,
        content: message,
        timestamp: new Date().toISOString()
      };
      
      socketRef.current.send(JSON.stringify(data));
      
      // Ð”Ð¾Ð´Ð°Ñ”Ð¼Ð¾ Ð¿Ð¾Ð²Ñ–Ð´Ð¾Ð¼Ð»ÐµÐ½Ð½Ñ Ð²Ñ–Ð´Ð¿Ñ€Ð°Ð²Ð½Ð¸ÐºÐ°
      setMessages(prev => [...prev, {
        id: Date.now(),
        type: 'own',
        content: `ðŸ“¤ ${message}`,
        timestamp: new Date().toISOString()
      }]);
      
      return true;
    }
    return false;
  }, [isConnected]);

  const sendPrivateMessage = useCallback((message, targetId) => {
    if (socketRef.current && isConnected) {
      const data = {
        type: 'private_message',
        to: targetId,
        content: message,
        timestamp: new Date().toISOString()
      };
      
      socketRef.current.send(JSON.stringify(data));
      
      setMessages(prev => [...prev, {
        id: Date.now(),
        type: 'own',
        content: `ðŸ”’ ÐŸÑ€Ð¸Ð²Ð°Ñ‚Ð½Ð¾ Ð´Ð¾ ${targetId}: ${message}`,
        timestamp: new Date().toISOString()
      }]);
      
      return true;
    }
    return false;
  }, [isConnected]);

  const joinRoom = useCallback((roomName) => {
    if (socketRef.current && isConnected) {
      const data = {
        type: 'join_room',
        room: roomName,
        timestamp: new Date().toISOString()
      };
      
      socketRef.current.send(JSON.stringify(data));
      return true;
    }
    return false;
  }, [isConnected]);

  const leaveRoom = useCallback((roomName) => {
    if (socketRef.current && isConnected) {
      const data = {
        type: 'leave_room',
        room: roomName,
        timestamp: new Date().toISOString()
      };
      
      socketRef.current.send(JSON.stringify(data));
      return true;
    }
    return false;
  }, [isConnected]);

  const ping = useCallback(() => {
    if (socketRef.current && isConnected) {
      const data = {
        type: 'ping',
        timestamp: new Date().toISOString()
      };
      
      socketRef.current.send(JSON.stringify(data));
      return true;
    }
    return false;
  }, [isConnected]);

  const clearMessages = useCallback(() => {
    setMessages([]);
  }, []);

  useEffect(() => {
    return () => {
      if (socketRef.current) {
        socketRef.current.close();
      }
    };
  }, []);

  return {
    isConnected,
    messages,
    error,
    connect,
    disconnect,
    sendMessage,
    sendPrivateMessage,
    joinRoom,
    leaveRoom,
    ping,
    clearMessages
  };
}; 